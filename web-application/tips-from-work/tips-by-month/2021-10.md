# Note

- 10.27 小记

  以前总在想，面试问这些基础知识、一些边边角角的东西有什么用，例如 http 协议，一些框架的实现原理；以前做的都是小项目，自然是没有意识到这些东西的重要性，在一个有着悠久历史的软件项目中，编码习惯，以及对一些边边角角的知识点就很有作用了；

  今天的想法：在看一个历史遗留 bug 的时候发现，之前的开发同学在 Vue 开发的 web 项目中，在父组件的 created 生命周期触发了一个全局事件，而这个全局事件是在子组件的 created 中挂载的，很明显这第一时间不会触发；之前组长面试的时候问过我这个问题，我并没有回答出来，之后则写了一个 demo，验证了在 Vue 组件中生命周期的顺序，因此记得比较清楚；

  到了大厂以后自己又有些放纵了，每日都是峡谷游戏；今天这个 bug 警示到了我：如果停止学习，或者对一些“边边角角”的知识/特性不加留意，那么很有可能会在自己的代码中留下一些坑让后人贻笑大方了。

- 10.28 利用状态机管理 UI （一）

  以前看外包写代码，经常会用各种各样的 flag 去管理页面中的状态（标记位处理问题）；
  例如：

  - 请求接口失败了，设置一个叫做 showError 的变量用于记录；
  - 表示正在请求中，设置一个叫做 isLoading 的东西来表示 loading 状态；
  - ...各种边界状况、各种条件

  如此持续增加补丁，只会造成可读性、可维护性、可测试性的同步变差；后一个接手代码的人，会惊叹这是 💩 山吧。

  如何解决这种困扰呢？

  这种时候，可以通过有限状态机的概念去进行一个设计：
  我们将整个任务区分为几个模块，分别是

  - **状态 State**
    记录当前业务的状态；例如系统正在 loading，系统正在 queueing...
  - **事件 Event**
    事件就是改变状态的事情，例如 Event.LOAD_END 改变 State，使系统停止被 loading
  - **转移 Transition**
    状态变更的动作，事件导致转移。
  - **动作 Action**
    可以是用户做的事情、也可以是系统做的事情；进入某个状态，则执行某个动作，进行了某个动作，触发了某个事件...

  有没有觉得很眼熟？Vuex 就是这种状态管理的东西，但我自己在使用的是，总是把它当成一个简单的存取状态的库，直到最近我才逐渐将它真正用作一个可以帮助我进行事件驱动的工具。

  到这里可能已经有一些启发了，已经准备好写下几个模块的 switch cases，帮助自己减少莫名其妙的 flag，但是其实还有更好的办法。

- 10.29 利用状态机管理 UI （二）
