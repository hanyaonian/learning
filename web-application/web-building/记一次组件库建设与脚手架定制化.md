### 任务背景

过完年回来，组织上给我的任务是：开发一个移动端的 web 组件库，供其他项目使用，开发完成后试点开发并且维护更新。原本的项目，使用的是较为流行且开源的 vant 组件库来提升开发效率。美中不足的是，组件的样式上和功能上和部门的设计风格有出入，或者有些组件不存在；样式上的差异，还可以通过覆盖样式去改改，但是功能上的差异则需要重新开发。实际上，真正需要重新做的业务组件大概不超过十个，但是为了方便部门内的项目共通（即不要每个项目都重新做或者去旧的项目拷一份出来，或者修了个 bug 大家把补丁发来发去），还是拍板决定重新做一套了。

个人认为，一个组件库是否好使很大程度上依赖其可读性和通用性：组件可能设计的很出彩，但是文档/demo 不好看甚至没有，那么也不能指望开发去阅读源码来获知这个组件的使用方式；其次通用性也很重要，就是这个组件要给足够多的拓展空间和配置项，以便不同项目在保持一定的一致性上做出对应的功能拓展。一个好的组件库脚手架可以省去很多开发的功夫，让整个开发过程可以专注于文档编写、demo 编写、组件编写，而不需要去考虑这个组件的打包、兼容性等各方面的配置（虽然研究一下也没有坏处）。

考虑到工期以及自己重新做一个用于展示组件的文档会存在一定的困难和潜在问题（避免重复造糟糕的轮子），在几个比较知名的组件库提供的脚手架中，选择了 vant 的组件库脚手架：[vant-cli](https://github.com/youzan/vant). 为什么选择 vant：

1. 其脚手架支持多种配置，vue3、vue2 以及 less、sass 都可以配置支持。
2. 其脚手架生成的文档风格开发更熟悉，相对来说更好阅读和上手。
3. [项目代码结构](https://github.com/youzan/vant/blob/dev/packages/vant-cli/docs/directory.md)清晰，看着就很好维护。

#### 组件库统一风格的基础：使用样式基类

第一步是先写基础组件以及基础样式。此外，样式基类这个名词我不知道存不存在。。。主要思想是维护一个公共的样式（包含常用的类、mixin 之类的，减少重复冗余的 css）。个人认为类似 Bulma 那种 css 框架的编写风格非常合适（css 类语义化）组件库的开发；开发者只需要定义好符合设计规范样式基础类，后续的组件开发中就可以只写 css 类和引用通用的 mixin，如果设计要对统一的设计风格进行改动，也只需要修正样式基类中的内容。举个例子：

```scss
// 统一字体级别
@mixin FontLevel($level) {
  $fontSize: 22, 20, 18... etc;
  $lineHeight: 40, 28, 24... etc;
  font-size: nth($fontSize, $level);
  line-height: nth($lineHeight, $level);
}

// 统一正文、提示语、标题等内容的类样式
// basic-class.scss
.title-1 {
  @include FontLevel(1);
}
.label-1 {
  @include FontLevel(7);
}

// in Button.vue
.vui-button {
  &-mini {
    @include FontLevel(7);
  }
  &-medium {
    @include FontLevel(6);
  }
  // ... etc
}
```

类似的例子还有很多，最直观的标准就是看 sfc 单文件 vue 中的还有没有不是用通用样式声明的组件样式，如果有而且还不是该组件独有的，那么这个样式变量可能会是下一次风格变动中的漏网之鱼。
最理想的标准是，组件非独有的样式全部用通用样式变量，独有的样式用组件自己的变量去维护，且保持一定的名字语义，如 $button-border-radius-mini, 让人很容易找到其对应的内容，方便修改。

### 考虑框架升级以及代码可维护性 - 修改脚手架代码以支持 composition-api 重写

在 20 年底的时候，Vue 就已经放出了 Vue3 的消息，也给 Vue2 增加了一个库----- composition-api，方便开发者们提前去了解 vue3 中比较重要的一个新特性：组合式 api 。实际上，不是大型的组件，用不用组合式 api 无伤大雅，毕竟组合式 api 设计出来的本意是为了让代码段落的关注点更加集中，代码更好复用且提升可读性。以前 Option Api 的写法，不管这个代码是做什么的，data 数据相关的就一块，computed 的就放一块，这个写法已经让我难受了一段时间了。例如有些时候维护些老代码，ctrl+f 搜一个变量可以上蹿下跳个半天，看着就头疼。所以，在组件库写了一段时间后，我决定用组合式 api 重写，这样也更方便迁移到 Vue3 的版本。

直接在 vant-cli 中使用组合式 api 的写法，会无法使用其特性并报错。因为这是一个插件，需要在 Vue 挂载前去执行 use 添加的。那么这也很好处理，在 node_modules 中看到 vant/cli 的源码，会发现其给自己的文档页配置了两个入口: mobile 和 desktop, 分别对应移动/桌面访问组件库网站时的页面入口。在两个入口文件 main 中加上对组合式 api 的依赖，再重新运行，ok，可以使用了～～～！

但这样有个新的问题，node_modules 里的东西，难道每次都要去改吗？重新装了就没了呀～～这个问题很简单，下载 vant-cli 的源代码，将自己的修改存放到源码中，并将其 publish 到私服上，然后组件库里的 vant-cli 不用公网的而是私服就可以解决问题啦，想怎么改怎么改～～～（私服使用 Nexus 搭建，可以代理 npm 官网的源也可以作为私服存不公开的软件包，不多赘述）

包括站点定制，以及一些其他功能的调整，都可以在私服上的 vant-cli 进行修改并发布，让文档站点风格变得完美符合 ux 的需求（之前开发的时候 ux 路过以为完全照抄 vant 官网，这也太伤人了～～～）

此外，不得不感叹一下 vant 和 vant-cli 都写的好好，代码逻辑还是分的很细的。一开始用 compostion-api + ts 重写，dev 环境以及编译网站都是好好的，但是在 build 组件时却发现静态资源会引用不存在，且打包出来的 es、lib 两种模式都无法正常使用。仔细一看会发现， 用来生成 vnode 的 render 函数还有 style import 都不见了，看起来像是 build 的过程出现的问题呀。那么顺着 vant-cli 的源码一看很快就发现问题（command -> file compile -> sfc compile， 代码结构很清晰，很方便定位到问题，点赞），原来有两个原因:

1. sfc compile 的时候没有考虑到 typescript 的支持(编译文件后整合编译出来的资源时出现差错)。为了支持类型判断，vue 组件使用 ts 时都是用 defineComponent 去做默认 exort 的对象的，而 vant-cli v2.x 的时候没有考虑到这个问题。
2. static file(svg, png 等)没有相应的处理逻辑，因为大部分组件库都是用 iconfont 去做 icon，只有我们这还在搞 png。。。

定位到问题一切都好说了：

- 图片打包问题：
  首先增加一个 static file 的 handler，不然都找不到我的 loading 图片了 QAQ
  ![image bug fix](https://michaelhan.tech/images/61b0793b2b22250bb6c64ab0c0a058c6.jpeg)
  逻辑很简单：如果传过来的图片，正则检查出来是静态图片文件啥的，就直接复制一份到输出目录不用做特殊处理。编译一看，ok 静态资源都引用到了～～

- composition-api + ts 编译问题
  这个问题还挺搞笑的，看到源码才发现实际上就是把编译过的资源通过替换字符串整合，如 script 部分，是把 _'export default {'_ 这个大家都会用来做首行的的代码前插入 render 函数 + staticRender 的部分，哈哈哈哈要是有人用多几个空格怎么办，那不是匹配不上了！！！！
  ![image bug fix](https://michaelhan.tech/images/d1245a29aa76fbf914a1ecd4a06c088a.jpeg)

  修改后换成可以支持 defineComponent 的那种写法，再把 injectStyle 的方法也作相应处理，问题就迎刃而解了！！！！
  ![image bug fix](https://michaelhan.tech/images/e394c4ba55c38ec7d039b4dbf6ac3154.jpeg)

然后又可以愉快的进行开发和组件更新了～～～其他的问题暂时还没有遇到，希望这些经验能帮助到想用组件库脚手架去做一些简单组件库的小伙伴们～～～
