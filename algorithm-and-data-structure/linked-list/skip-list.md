# Skip list 跳表

链表加多级索引的结构，等于 单链表实现的 二分查找。

应用场景: 检索

## Time complexity

ref

- 每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2k)。
  假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m\*logn)。
  每一级索引都最多只需要遍历 3 个结点。所以 m = 3.

![alt text](/assets/algorithm/skip-list.png)

- 插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn).

![alt text](/assets/algorithm/skip-list-2.png)

## 索引更新

通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

Why?

## Code example

```ts
/**
 * @description generated by doubao ai
 */
class SkipListNode<T> {
  value: T;
  forward: SkipListNode<T>[]; // 存储各层级的后继节点

  constructor(value: T, level: number) {
    this.value = value;
    this.forward = new Array(level).fill(null);
  }
}

export class SkipList<T> {
  private head: SkipListNode<T>; // 头节点
  private level: number; // 当前跳表的最高层级
  private maxLevel: number; // 最大允许的层级
  private p: number; // 晋升概率，通常为0.5

  constructor(maxLevel: number = 16, p: number = 0.5) {
    this.maxLevel = maxLevel;
    this.p = p;
    this.level = 1; // 初始层级为1
    this.head = new SkipListNode<T>(null as unknown as T, maxLevel);
  }

  /**
   * 生成新节点的随机层级
   */
  private randomLevel(): number {
    let level = 1;
    while (Math.random() < this.p && level < this.maxLevel) {
      level++;
    }
    return level;
  }

  /**
   * 插入一个值到跳表中
   * @param value 要插入的值
   */
  insert(value: T): void {
    const update: SkipListNode<T>[] = new Array(this.maxLevel).fill(null);
    let current: SkipListNode<T> = this.head;

    // 从最高层开始查找，记录每一层需要更新的节点
    for (let i = this.level - 1; i >= 0; i--) {
      while (current.forward[i] && current.forward[i].value < value) {
        current = current.forward[i];
      }
      update[i] = current;
    }

    // 生成新节点的随机层级
    const newLevel = this.randomLevel();

    // 如果新层级高于当前最高层级，更新相关信息
    if (newLevel > this.level) {
      for (let i = this.level; i < newLevel; i++) {
        update[i] = this.head;
      }
      this.level = newLevel;
    }

    // 创建新节点并插入
    const newNode = new SkipListNode<T>(value, newLevel);
    for (let i = 0; i < newLevel; i++) {
      newNode.forward[i] = update[i].forward[i];
      update[i].forward[i] = newNode;
    }
  }

  /**
   * 从跳表中删除一个值
   * @param value 要删除的值
   * @returns 是否删除成功
   */
  delete(value: T): boolean {
    const update: SkipListNode<T>[] = new Array(this.maxLevel).fill(null);
    let current: SkipListNode<T> = this.head;

    // 查找并记录每一层需要更新的节点
    for (let i = this.level - 1; i >= 0; i--) {
      while (current.forward[i] && current.forward[i].value < value) {
        current = current.forward[i];
      }
      update[i] = current;
    }

    // 检查下一个节点是否为要删除的节点
    current = current.forward[0];
    if (current && current.value === value) {
      // 更新各层级的指针
      for (let i = 0; i < this.level; i++) {
        if (update[i].forward[i] !== current) {
          break;
        }
        update[i].forward[i] = current.forward[i];
      }

      // 更新跳表的最高层级
      while (this.level > 1 && this.head.forward[this.level - 1] === null) {
        this.level--;
      }
      return true;
    }

    return false; // 未找到要删除的节点
  }

  /**
   * 在跳表中查找一个值
   * @param value 要查找的值
   * @returns 是否存在该值
   */
  search(value: T): boolean {
    let current: SkipListNode<T> = this.head;

    // 从最高层开始查找
    for (let i = this.level - 1; i >= 0; i--) {
      while (current.forward[i] && current.forward[i].value < value) {
        current = current.forward[i];
      }
    }

    // 检查下一个节点是否为目标节点
    current = current.forward[0];
    return current !== null && current.value === value;
  }

  /**
   * 打印跳表的结构（用于调试）
   */
  print(): void {
    console.log("Skip List Structure:");
    for (let i = 0; i < this.level; i++) {
      let current: SkipListNode<T> = this.head.forward[i];
      let line = `Level ${i}: `;
      while (current) {
        line += `${current.value} -> `;
        current = current.forward[i];
      }
      line += "null";
      console.log(line);
    }
  }
}

// 使用示例
const skipList = new SkipList<number>();
skipList.insert(3);
skipList.insert(6);
skipList.insert(7);
skipList.insert(9);
skipList.insert(12);

skipList.print();

console.log("Search for 7:", skipList.search(7)); // true
console.log("Search for 5:", skipList.search(5)); // false

skipList.delete(6);
skipList.print();
console.log("Search for 6 after deletion:", skipList.search(6)); // false
```
