# Composite 组合模式

目的:组合模式是一种结构型设计模式,可以使用它将对象组合成树状结构,并且能像使用独立对象一样使用它们.

## 场景分析

例如,有两类对象: 产品和盒子. 一个盒子中可以包含多个产品或者几个较小的盒子. 这些小盒子中同样可以包含一些产品或更小的盒子, 以此类推.

假设你希望在这些类的基础上开发一个定购系统. 订单中可以包含无包装的简单产品, 也可以包含装满产品的盒子..以及其他盒子. 此时你会如何计算每张订单的总价格呢?

![example](/assets/design-pattern/composite-example.png)

> 订单中可能包括各种产品, 这些产品放置在盒子中, 然后又被放入一层又一层更大的盒子中. 整个结构看上去像是一棵倒过来的树.

直接计算? 遍历每一个盒子, 这么做可能会有这样子的代码: box.open(), box.getItems(), isBoxOrProduct(item), 又一轮循环... 最后再去做一个汇总.

直接计算, 不同的产品可能还会有细节信息, 嵌套也极其复杂, 会十分的不方便.

### 解决问题

组合模式建议使用一个通用接口来与 产品和 盒子进行交互, 并且在该接口中声明一个计算总价的方法.

那么方法该如何设计呢? 对于一个产品, 该方法直接返回其价格； 对于一个盒子, 该方法遍历盒子中的所有项目, 询问每个项目的价格, 然后返回该盒子的总价格. 如果其中某个项目是小一号的盒子, 那么当前盒子也会遍历其中的所有项目, 以此类推, 直到计算出所有内部组成部分的价格. 你甚至可以在盒子的最终价格中增加额外费用, 作为该盒子的包装费用.

该方式的最大优点在于你无需了解构成树状结构的对象的具体类. 你也无需了解对象是简单的产品还是复杂的盒子. 你只需调用通用接口以相同的方式对其进行处理即可.
当你调用该方法后, 对象会将请求沿着树结构传递下去.

### Real-life example

- Army, Company...

## When & How

### When

- 树状对象结构
- 所有元素均共用同一个接口, 客户端不关心对象具体类

### How

- 区分元素与容器: 容器中可以包含其他容器, 也可以包含元素
- 声明复杂与简单节点(容器与元素)的统一接口
- 使用叶子节点表明简单元素(叶子节点为多种类)
- 使用容器表明复杂元素, 实现统一接口时, 复杂元素的工作结果应该向下传递给子节点(简单元素)
- 定义添加、删除子元素的方法

## Reference

-https://refactoringguru.cn/design-patterns/composite
