## Chapter 2 Javascript In HTML

#### <script>

- **async** 即刻下载脚本（仅外部），且不阻塞页面其他动作(如下载资源以及其他脚本加载)，**不保证加载执行顺序**
- **crossorigin** 默认不使用，‘anonymous’文件请求不必设置凭据标志，‘use-credentials’设置凭据标志，标示出站请求会包含
- **defer** 标示脚本（仅外部）延迟加载，文档完全被解析执行后再显示，**defer 保证加载执行顺序，实际不一定**，run after domInteractive, before domContentLoaded
- **integrity** 签名比对，用于查看资源内容有无被更改，可用于校验 cdn 分发的文件有无被恶意篡改
- **type** type 为 module 时才可以使用 export 和 import

- js 文件按顺序加载，前面的解释完毕才能解释下一个（以前遇到的引用顺序问题）。
- css 放在 body 前，js 放在 body 后：老生常谈，不阻塞页面加载渲染了。
- 动态加载脚本：js 插入 link rel=‘preload‘ href=’..js‘ 保证动态脚本的优先级

补充：

1. 同步脚本（标签中不含 async 或 defer）： <script src="***.js" charset="utf-8"></script>当 HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。
2. defer 脚本：<script src="***.js" charset="utf-8" defer></script>当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关（时机不一定）。
3. 当 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析。

## Chapter 3、4 Some Basic Knowledge

###### 作用域

- let: 块作用域， var: 函数作用域你
- var 声明会被拿到函数或全剧作用域的定吧，位于作用域中所有代码之前（变量提升）
- let 不会被作用域提升，所以声明前的区域是’暂时性死区‘；全局作用域声明的 let 变量不会变成全局变量；let 也不能依赖条件声明模式

// 避免忘了 symbol 有点点特殊，btw Symbol 用的实在实在太少了。。。
let s1 = Symbol('123');
let o = {
[s1]: 123
}

###### 垃圾回收

- 标记清除法：变量进入上下文时，会被添加一个存在于上下文的标记，当变量离开上下文时，添加一个离开的标记，然后周期性回收带有离开标记的变量。垃圾回收运行时：先标记所有，再移除在上下文上以及被上下文引用的变量的标记，在此之后其他带标记的变量都是要被回收的了。
- 引用计数法：现在比较少浏览器使用这个，因为出现循环引用时，变量永远不会被回收。如构建 tiertree 时父子互指，就会互相计数永远不正确永远不回收。
- 实际应用：
  1.  解除引用，如各类全局变量、全局属性、事件监听器等
  2.  v8 会将创建的对象和隐藏类关联起来，用以跟踪它们的属性特征；共享相同隐藏类的对象性能会更好。避免“先创建对象再补充属性”，（好的方式：在构造函数里一次性声明所有属性）可以更好的共享隐藏类。
  3.  闭包引用。例如：定时器里通过闭包引用了变量，变量不会回收；闭包返回的内容如果太大也会造成一定的内存占用。
